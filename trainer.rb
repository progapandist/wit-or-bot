require_relative 'rubotnik/wit_understander'
# require_relative 'rubotnik/tagger'

# returns a hash of form {"start" => start_index, "end" => end_index}
def substring_offset(string, substring)
  match = string.match(/#{substring}/i)
  return nil if match.nil?
  match.offset(0).zip(%w[start end]).to_h.invert
end

# p substring_offset("I want to buy apples or oranges", "oranges")

# takes an original string, a string of substrings
# and an entity name as symbol, separates sunstrings on 'OR' or ','
# returns an array of "entity" hashes
def assign_word_entities(string, substrings, entity_name)
  words = substrings.split(", ") # split on comma if not separated by 'or's
  words = substrings.split(" or ") if substrings =~ / or /
  words.each.map do |word|
    { "entity" => entity_name.to_s }.merge(substring_offset(string, word))
  end
end

# Takes original string and a trait name as symbol
def assign_trait_entity(trait, value)
  {
    "entity" => trait.to_s,
    "value" => value
  }
end

# takes an original string, hash generated by assign_trait_entity
# and array of hashes generated by assign_word_entities
def build_training_sample(string, trait_entity: nil, word_entities: nil)
  entities = []
  entities << trait_entity unless trait_entity.nil?
  entities += word_entities unless word_entities.nil?
  [{ "text" => string, "entities" => entities }]
end

phrase = "Should I be a good boy or a bad boy?"
word = Rubotnik::WitUnderstander.build_word_entities(phrase, "good boy, bad boy", :option)
trait = Rubotnik::WitUnderstander.build_trait_entity(:intent, "or_question")
p "=========="

understander = Rubotnik::WitUnderstander.new("ZI243GVZYMZFWGIFMGI4PNUNLGVFLFUZ")
p understander.train(phrase, trait_entity: trait, word_entities: word)
